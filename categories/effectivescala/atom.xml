<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: effectivescala | Bytes.Codes]]></title>
  <link href="http://bytes.codes/categories/effectivescala/atom.xml" rel="self"/>
  <link href="http://bytes.codes/"/>
  <updated>2015-08-29T13:31:22-07:00</updated>
  <id>http://bytes.codes/</id>
  <author>
    <name><![CDATA[Brendan McAdams]]></name>
    <email><![CDATA[brendan@bytes.codes]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding Scala's Type Classes]]></title>
    <link href="http://bytes.codes/2012/06/11/Understanding_Scala_Type_Classes/"/>
    <updated>2012-06-11T00:00:00-07:00</updated>
    <id>http://bytes.codes/2012/06/11/Understanding_Scala_Type_Classes</id>
    <content type="html"><![CDATA[<p>Over the last year or so, I have found myself making more and more use of Scala’s Type Class system to add flexibility to my code.  This is especially evident in the MongoDB Scala Driver, <a href="Casbah">http://github.com/mongodb/casbah</a>, where the most recent work has been to simplify many features by migrating them to type classes.</p>

<p>During this work however, I’ve found during that many otherwise adroit Scala engineers seem befuddled or daunted by the Type Class. It does me no good to take advantage of clever features that my users don’t understand, and many will benefit from introducing these concepts to their own code. So let’s take a look at what type classes are, as well as how &amp; why we can utilize them.</p>

<p>Wikipedia defines a Type Class as <em>“… a type system construct that supports ad-hoc polymorphism. This is achieved by adding constraints to type variables in parametrically polymorphic types”</em>. Admittedly, a bit of a mouthful – and not very helpful to those of us who are self taught and lack the benefit of a comprehensive academic Computer Science education (myself included). Surely, there must be a way to simplify this concept?</p>

<p>In evaluating these ideas, I’ve found it easiest to think of a Type Class (in Scala, at least) as a special kind of <em>adapter</em>, which can impart additional capabilities upon a given type or set of types. In Scala the Type Class is communicated through <em>implicits</em>, and imparts one, or both, of two behaviors. First, a Type Class can be to utilized to <em>filter</em> what types are valid for a given method call (which I detailed in <a href="/2011/07/13/User_Configgable_Type_Filtering_with_Type_Classes/">this earlier post</a>). Second, a Type Class can impart additional features and behaviors upon a type at method invocation time. This latter is much along the lines of an enhanced kind of composition, rather than the weaker inheritance which often plagues similar behaviors in a language like Java.</p>

<p>To better understand what I am describing, let’s compare a few concepts around the creation and interaction of custom domain objects. I have several sets of tasks I have had to accomplish in Scala in the past – and Scala solutions show some elegant Type Class oriented approaches which are rooted in the Standard Library. While this may seem a bit contrived, it is exactly the kind of problem through which <em>I</em> initially came to understand Type Classes –– and is thus an ideal lesson.</p>

<!--more-->
<p>First, let’s take a look at <em>sorting</em> and custom objects to best understand how one accomplishes this. It is not an uncommon task in development for us to create our own objects and need to integrate them into Standard Library behaviors, such as sorting. Let’s work with a few sample objects in the form of “Bank Accounts” to look at how this all work (and I’m aware of the poor concurrency control, etc. around balance – this is a contrived example). Here’s our Bank Account object:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">BankAccount</span><span class="o">(</span><span class="k">val</span> <span class="n">accountNumber</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="k">val</span> <span class="n">holderFirst</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                  <span class="k">val</span> <span class="n">holderMiddle</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="k">val</span> <span class="n">holderLast</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                  <span class="k">var</span> <span class="n">balance</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="n">holderName</span> <span class="k">=</span> 
    <span class="err">“</span><span class="o">%</span><span class="n">s</span><span class="o">,</span> <span class="o">%</span><span class="n">s</span> <span class="o">%</span><span class="n">s</span><span class="err">”</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="n">holderLast</span><span class="o">,</span> <span class="n">holderFirst</span><span class="o">,</span> <span class="n">holderMiddle</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="err">“”</span><span class="o">))&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> 
    <span class="err">“</span><span class="o">{</span> <span class="nc">Acct</span> <span class="k">#</span> <span class="o">%</span><span class="n">s</span><span class="o">,</span> <span class="nc">Held</span> <span class="n">by</span> <span class="o">%</span><span class="n">s</span> <span class="k">with</span> <span class="n">a</span> <span class="n">balance</span> <span class="n">of</span> <span class="n">$</span><span class="o">%</span><span class="mf">8.2f</span><span class="o">}</span><span class="err">”</span><span class="o">.</span><span class="n">format</span><span class="o">(</span>
        <span class="n">accountNumber</span><span class="o">,</span> <span class="n">holderName</span><span class="o">,</span> <span class="n">balance</span>
    <span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span></code></pre></div></p>

<p>We can easily populate collections with instances of these accounts as well.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">accounts</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="k">new</span> <span class="nc">BankAccount</span><span class="o">(</span><span class="mi">1000893</span><span class="o">,</span> <span class="err">“</span><span class="nc">Brendan</span><span class="err">”</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="err">“</span><span class="n">W</span><span class="o">.</span><span class="err">”</span><span class="o">),</span> <span class="err">“</span><span class="nc">McAdams</span><span class="err">”</span><span class="o">,</span>
                                    <span class="mf">1234.56</span><span class="o">),</span>
                    <span class="k">new</span> <span class="nc">BankAccount</span><span class="o">(</span><span class="mi">1000256</span><span class="o">,</span> <span class="err">“</span><span class="nc">John</span><span class="err">”</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="err">“</span><span class="nc">Smith</span><span class="err">”</span><span class="o">,</span> 
                                    <span class="mf">10000291.83</span><span class="o">),</span>
                    <span class="k">new</span> <span class="nc">BankAccount</span><span class="o">(</span><span class="mi">1000012</span><span class="o">,</span> <span class="err">“</span><span class="nc">Jane</span><span class="err">”</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="err">“</span><span class="nc">Doe</span><span class="err">”</span><span class="o">,</span> 
                                    <span class="mf">45.28</span><span class="o">),</span>
                    <span class="k">new</span> <span class="nc">BankAccount</span><span class="o">(</span><span class="mi">4002158</span><span class="o">,</span> <span class="err">“</span><span class="nc">Alan</span><span class="err">”</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="err">“</span><span class="nc">Smithee</span><span class="err">”</span><span class="o">,</span> 
                                    <span class="mf">834567.00</span><span class="o">))&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">println</span><span class="o">(</span><span class="err">“</span><span class="nc">Bank</span> <span class="nc">Accounts</span><span class="k">:</span> <span class="err">“</span> <span class="kt">+</span> <span class="kt">accounts</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>Given collections of instances of these bank accounts in each language, we’d like to easily sort them –– given an arbitrary set of requirements.  Now, neither Scala or Java can “automatically” figure out how to sort these, instead requiring assistance from us (the developer).</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">sortedAccounts</span> <span class="k">=</span> <span class="n">accounts</span><span class="o">.</span><span class="n">sorted</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">println</span><span class="o">(</span><span class="err">“</span><span class="o">*</span> <span class="nc">Sorted</span> <span class="nc">Accounts</span><span class="k">:</span> <span class="err">“</span> <span class="kt">+</span> <span class="kt">sortedAccounts</span><span class="o">)</span></code></pre></div></p>

<p>It is unfortunately not <em>quite</em> that easy, as the above code will fail to compile asking for a missing argument:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nc">BankAccount</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">39</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">implicit</span> <span class="kt">Ordering</span> <span class="kt">defined</span> <span class="kt">for</span> <span class="kt">this.BankAccount.</span>
<span class="kt">val</span> <span class="kt">sortedAccounts</span> <span class="o">=</span> <span class="n">accounts</span><span class="o">.</span><span class="n">sorted</span>
                                    <span class="o">^</span>
<span class="n">one</span> <span class="n">error</span> <span class="n">found</span></code></pre></div></p>

<p>Like in Java, we need to provide Scala information about how to sort a class of type <code>BankAccount</code>.  In Java however, we would need to use inheritance and actually change the structure of <code>BankAccount</code> by implementing the <code>Comparable</code> interface.  Personally, I’ve never been a fan of that approach – changing a class directly can lead to behavioral oddities. It also has two major limitations that I’ve run into in the past.</p>

<p>First we get locked into only <em>one</em> way to sort a <code>BankAccount</code>. If initially we want to sort by <code>accountNumber</code>, and code that in we are restricted should another part of our application need to sort by <code>balance</code>. We either work around the builtin sort methods or subclass, introducing more complications.</p>

<p>Second, we are severely restricted in our ability to handle this with a third party class. What if <code>BankAccount</code> is a vendor supplied class and is <code>final</code> so we cannot even create an extended version which implements comparable? Suddenly we are restricted from taking advantage of the sort routines built into the standard library and have to reinvent our own. Not ideal.</p>

<p>Instead, with Scala, the implementation of our <code>Comparable</code> equivalent is done externally in a Type Class of type <code>scala.math.Ordering</code>. When implemented, our instance of <code>Ordering</code> will both control what classes can be sorted as well as providing information about how to sort. But because it is implemented externally and provided as an implicit we can provide multiple versions should we need different sorting behaviors down the line*.</p>

<p>It is important to note that a Type Class in Scala is typically <em>stateless</em>. It is provided to callers as a single static instance based on Type, and only infers necessary state information from <em>instances of the referenced type</em> passed to its methods. The Type Class is controlling how instances of a given type should behave generically and should be side effect free.</p>

<p>The normal way of providing a typeclass is to create a static implicit object of a trait implementation of <code>TypeClass[A]</code> in scope. I prefer to declare the base trait separately from the implicit object to encourage easier reusage.</p>

<p>For providing <a href="http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/scala/math/Ordering.html">Ordering[BankAccount]</a>, we need to implement an abstract method <code>def compare(x: T, y: T): Int</code> which compares two instances of <code>T</code> (Where, in this case, <code>T</code> represents <code>BankAccount</code>) and returns an <code>Int</code> signifying their order against one another. Negative represents that <code>x &lt; y</code>, positive that <code>x &gt; y</code> and zero if <code>x == y</code>.</p>

<p>Let’s take a look at how our <code>Ordering</code> instance for sorting a <code>BankAccount</code> by <code>accountNumber</code> might look.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">BankAccountNumberOrder</span> <span class="k">extends</span> <span class="n">scala</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="nc">Ordering</span><span class="o">[</span><span class="kt">BankAccount</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BankAccount</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BankAccount</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">accountNumber</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">y</span><span class="o">.</span><span class="n">accountNumber</span><span class="o">)</span> 
      <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">accountNumber</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">y</span><span class="o">.</span><span class="n">accountNumber</span><span class="o">)</span> 
      <span class="mi">1</span>
    <span class="k">else</span>
      <span class="mi">0</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">implicit</span> <span class="k">object</span> <span class="nc">BankAccountNumberSort</span> <span class="k">extends</span> <span class="nc">BankAccountNumberOrder</span></code></pre></div></p>

<p>Now with an implicit instance of <code>Ordering[BankAccount]</code> in scope, our sort can succeed. Running our code should produce expected results:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nc">Bank</span> <span class="nc">Accounts</span><span class="k">:</span> <span class="kt">List</span><span class="o">({</span> <span class="kt">Acct</span> <span class="k">#</span> <span class="err">1000893</span><span class="o">,</span> <span class="kt">Held</span> <span class="kt">by</span> <span class="kt">McAdams</span><span class="o">,</span> <span class="kt">Brendan</span> <span class="kt">W.</span> <span class="kt">with</span> <span class="kt">a</span> <span class="kt">balance</span> <span class="kt">of</span> <span class="kt">$</span> <span class="err">1234</span><span class="kt">.</span><span class="err">56</span><span class="o">},</span> <span class="o">{</span> <span class="nc">Acct</span> <span class="k">#</span> <span class="mi">1000256</span><span class="o">,</span> <span class="nc">Held</span> <span class="n">by</span> <span class="nc">Smith</span><span class="o">,</span> <span class="nc">John</span>  <span class="k">with</span> <span class="n">a</span> <span class="n">balance</span> <span class="n">of</span> <span class="n">$10000291</span><span class="o">.</span><span class="mi">83</span><span class="o">},</span> <span class="o">{</span> <span class="nc">Acct</span> <span class="k">#</span> <span class="mi">1000012</span><span class="o">,</span> <span class="nc">Held</span> <span class="n">by</span> <span class="nc">Doe</span><span class="o">,</span> <span class="nc">Jane</span>  <span class="k">with</span> <span class="n">a</span> <span class="n">balance</span> <span class="n">of</span> <span class="n">$</span>   <span class="mf">45.28</span><span class="o">},</span> <span class="o">{</span> <span class="nc">Acct</span> <span class="k">#</span> <span class="mi">4002158</span><span class="o">,</span> <span class="nc">Held</span> <span class="n">by</span> <span class="nc">Smithee</span><span class="o">,</span> <span class="nc">Alan</span>  <span class="k">with</span> <span class="n">a</span> <span class="n">balance</span> <span class="n">of</span> <span class="n">$834567</span><span class="o">.</span><span class="mi">00</span><span class="o">})&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nc">Sorted</span> <span class="nc">Accounts</span><span class="k">:</span> <span class="kt">List</span><span class="o">({</span> <span class="kt">Acct</span> <span class="k">#</span> <span class="err">1000012</span><span class="o">,</span> <span class="kt">Held</span> <span class="kt">by</span> <span class="kt">Doe</span><span class="o">,</span> <span class="kt">Jane</span>  <span class="kt">with</span> <span class="kt">a</span> <span class="kt">balance</span> <span class="kt">of</span> <span class="kt">$</span>   <span class="err">45</span><span class="kt">.</span><span class="err">28</span><span class="o">},</span> <span class="o">{</span> <span class="nc">Acct</span> <span class="k">#</span> <span class="mi">1000256</span><span class="o">,</span> <span class="nc">Held</span> <span class="n">by</span> <span class="nc">Smith</span><span class="o">,</span> <span class="nc">John</span>  <span class="k">with</span> <span class="n">a</span> <span class="n">balance</span> <span class="n">of</span> <span class="n">$10000291</span><span class="o">.</span><span class="mi">83</span><span class="o">},</span> <span class="o">{</span> <span class="nc">Acct</span> <span class="k">#</span> <span class="mi">1000893</span><span class="o">,</span> <span class="nc">Held</span> <span class="n">by</span> <span class="nc">McAdams</span><span class="o">,</span> <span class="nc">Brendan</span> <span class="n">W</span><span class="o">.</span> <span class="k">with</span> <span class="n">a</span> <span class="n">balance</span> <span class="n">of</span> <span class="n">$</span> <span class="mf">1234.56</span><span class="o">},</span> <span class="o">{</span> <span class="nc">Acct</span> <span class="k">#</span> <span class="mi">4002158</span><span class="o">,</span> <span class="nc">Held</span> <span class="n">by</span> <span class="nc">Smithee</span><span class="o">,</span> <span class="nc">Alan</span>  <span class="k">with</span> <span class="n">a</span> <span class="n">balance</span> <span class="n">of</span> <span class="n">$834567</span><span class="o">.</span><span class="mi">00</span><span class="o">})</span></code></pre></div></p>

<p>The big benefit here (in my eyes) is that we didn’t need to modify our <code>BankAccount</code> class at all to provide this behavior. <em>Even if <code>BankAccount</code> was a sealed third party class</em> we can provide sorting information for it. This is far superior to an inheritance based solution such as Java’s. And if we wanted later to sort by <code>balance</code> instead of <code>accountNumber</code> we can explicitly pass a different instance to sort:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">BankAccountBalanceOrder</span> <span class="k">extends</span> <span class="n">scala</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="nc">Ordering</span><span class="o">[</span><span class="kt">BankAccount</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BankAccount</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BankAccount</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">balance</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">y</span><span class="o">.</span><span class="n">balance</span><span class="o">)</span> 
      <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">balance</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">y</span><span class="o">.</span><span class="n">balance</span><span class="o">)</span> 
      <span class="mi">1</span>
    <span class="k">else</span>
      <span class="mi">0</span>
<span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">sortedByBalance</span> <span class="k">=</span> <span class="n">accounts</span><span class="o">.</span><span class="n">sorted</span><span class="o">(</span><span class="nc">BankAccountBalanceOrder</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">println</span><span class="o">(</span><span class="err">“</span><span class="n">$</span> <span class="nc">Sorted</span> <span class="nc">By</span> <span class="nc">Balance</span><span class="k">:</span> <span class="err">“</span> <span class="kt">+</span> <span class="kt">sortedByBalance</span><span class="o">)</span></code></pre></div></p>

<p>Complete control is passed to us from an externally controlled system. I’ll save the details for a future post, but we can even use a type class to define what it means if I say <code>brendansAccount - johnsAccount</code> using an instance of <code>scala.math.Numeric[BankAccount]</code>.</p>

<p>Now go forth and Type with Class.</p>

<p>* <a href="http://twitter.com/djspiewak">Daniel Spiewak</a> points out that Sun realized this complication as well a few Java releases back and introduced <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Comparator.html">Comparator</a>, which is very similar to this Type Class approach.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Forcing Scala Compiler 'Nothing' Checks]]></title>
    <link href="http://bytes.codes/2012/05/31/Forcing_Compiler_Nothing_checks/"/>
    <updated>2012-05-31T00:00:00-07:00</updated>
    <id>http://bytes.codes/2012/05/31/Forcing_Compiler_Nothing_checks</id>
    <content type="html"><![CDATA[<p>Since early in its history, Casbah has had a helper method called <code>getAs[T]</code>, where <code>T</code> is “Some type you’d like to fetch a particular field as”. Because of type erasure on the JVM, working with a Mongo Document can be annoying – the representation in Scala is the equivalent of a <code>Map[String, Any]</code>. If we were to work with the <code>Map[String, Any]</code> in a standard mode, fetching a field <em>balance</em> which is a <code>Double</code> would require manual casting.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">DBObject</span> <span class="o">=</span> <span class="nc">MongoDBObject</span><span class="o">(</span><span class="err">“</span><span class="n">foo</span><span class="err">”</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="n">bar</span><span class="err">”</span><span class="o">,</span> <span class="err">“</span><span class="n">balance</span><span class="err">”</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mf">2.5</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">balance</span> <span class="k">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="err">“</span><span class="n">balance</span><span class="err">”</span><span class="o">)</span></code></pre></div></p>

<p>We have already hit another issue here – in Scala, invoking <code>get</code> on a <code>Map</code> returns <code>Option[T]</code> (Where, in this case, <code>T</code> is of type <code>Any</code>). Which means casting has become more complex: to get a <code>Double</code> we also have to unwrap the <code>Option[Any]</code> first. A lazy man’s approach might be something hairy like so:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">balance</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="kc">null</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span></code></pre></div></p>

<p>In the annals of history (when men were <em>real</em> men, and small furry creatures from Alpha Centauri were <em>real</em> small furry creatures from Alpha Centauri), the above became an annoyingly common pattern. A solution was needed - and so <code>getAs[T]</code> was born. The idea was not only to allow a shortcut to casting, but take care of the <code>Option[T]</code> wrapping for you as well. Invoking <code>getAs[Double]</code> will, in this case, return us an <code>Option[Double]</code>.</p>

<p>But not everything is perfect in the land of <code>getAs[T]</code> – if the type requested doesn’t match the actual type, runtime failures occur. Worse, if the user fails to pass a type, the Scala compiler substitutes <code>Nothing</code>, which <em>guarantees</em> a runtime failure. Runtime failures are bad – but fortunately, <a href="http://twitter.com/milessabin">Miles Sabin</a> &amp; <a href="http://twitter.com/jteigen">Jon-Anders Teigen</a> came up with an awesome solution.</p>

<!--more-->

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">doc</span><span class="o">.</span><span class="n">getAs</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;&amp;quot;foo&amp;quot;&quot;</span><span class="o">&gt;</span><span class="nc">String</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="cm">/* res1: Option[String] = Some(bar) &lt;em&gt;/’</span>
<span class="cm">doc.getAs&lt;a href=&quot;&amp;quot;balance&amp;quot;&quot;&gt;Double&lt;/a&gt;</span>
<span class="cm">/&lt;/em&gt; res2: Option[Double] = Some(2.5) &lt;em&gt;/</span>
<span class="cm">doc.getAs(“balance”)</span>
<span class="cm">/&lt;/em&gt; res3: Option[Nothing] = Some(2.5) */</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;/*</span> <span class="nc">Notably</span> <span class="n">at</span> <span class="n">least</span><span class="o">,</span> <span class="n">the</span> <span class="nc">Scala</span> <span class="n">compiler</span> <span class="n">is</span> <span class="n">smart</span> <span class="n">enough</span> <span class="n">to</span> <span class="n">infer</span> <span class="err">“</span><span class="n">A</span><span class="err">”</span> <span class="n">from</span> <span class="n">the</span> <span class="n">left</span><span class="o">-</span><span class="n">hand</span> <span class="n">side</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="k">if</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> 
   <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">declared</span> <span class="kt">&lt;em&gt;/</span> 
<span class="k">val</span> <span class="n">bal</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">getAs</span><span class="o">(</span><span class="n">doc</span><span class="o">,</span> <span class="err">“</span><span class="n">balance</span><span class="err">”</span><span class="o">)</span>
<span class="o">/&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">bal</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mf">2.5</span><span class="o">)</span> <span class="o">*/&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>We get back an option of <code>Nothing</code>, which is less than ideal (The REPL appears to be somewhat more forgiving in some of this behavior than the actual runtime is). My reaction to this early on was quite strong –– I wanted to <em>require</em> that the user pass their type argument. Unfortunately, the best I could do within Casbah was attempt to detect the compiler substituted <code>Nothing</code> and warn the user at runtime. Less than ideal, I know.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">getAs</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;key: String&quot;</span><span class="o">&gt;</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="k">:</span> <span class="kt">Any:</span> <span class="kt">Manifest&lt;/a</span><span class="k">&gt;:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">manifest</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">!=</span> <span class="n">manifest</span><span class="o">[</span><span class="kt">scala.Nothing</span><span class="o">],</span>
    <span class="err">“</span><span class="nc">Type</span> <span class="n">inference</span> <span class="n">failed</span><span class="o">;</span> <span class="n">getAs</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="o">&gt;</span><span class="n">A</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">requires</span> <span class="n">an</span> <span class="n">explicit</span> <span class="k">type</span> <span class="kt">argument</span> <span class="err">“</span> <span class="kt">+</span>
    <span class="err">“</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">dbObject</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">&lt;returntype&gt;</span><span class="o">](\</span><span class="s">&quot;somegetAKey\&quot;) ) to function correctly.&quot;</span><span class="o">)&lt;/</span><span class="n">returntype</span><span class="o">&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">underlying</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="kc">null</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">None</span>
    <span class="k">case</span> <span class="n">value</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<p>This gave me somewhat improved behavior –- at least users are warned at runtime before something breaks.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">doc</span><span class="o">.</span><span class="n">getAs</span><span class="o">(</span><span class="err">“</span><span class="n">balance</span><span class="err">”</span><span class="o">)</span>
<span class="cm">/* </span>
<span class="cm">java.lang.IllegalArgumentException: requirement failed: Type inference failed; getAs&lt;a href=&quot;&quot;&gt;A&lt;/a&gt; requires an explicit type argument (e.g. dbObject.getAs[&lt;returntype&gt;](&quot;somegetAKey&quot;) ) to function correctly.</span>
<span class="cm">*/</span></code></pre></div></returntype></p>

<p>Great – we prevent people from utterly failing to pass a type to <code>getAs</code> by throwing an exception at runtime. A bit like closing the barn doors after the horses escaped, and somewhat counter to the point of compiled languages. Fortunately, Miles Sabin knows a lot of great compiler tricks and Jon-Anders has superpowers (which he uses for good, not evil). Using some of Miles’ tricks, Jon-Anders has fixed Casbah (as of 2.3.0+) to make <code>getAs[T]</code> fail utterly at <em>compile time</em> when no type is passed.</p>

<p>The secret to this trick is essentially that the Scala compiler <em>hates</em> ambiguity. In order to substitute <code>Nothing</code> as a type argument when one isn’t supplied, the Scala compiler has an implicit for <code>Nothing</code> scoped. If one were to exacerbate the situation by introducing an additional implicit for <code>Nothing</code>, the compiler would fail when no type argument is passed.</p>

<p>With this in mind, we can morph <code>getAs</code> to work with a type class instead of a standard type argument.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">getAs</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;key: String&quot;</span><span class="o">&gt;</span><span class="n">A</span> <span class="k">:</span> <span class="kt">NotNothing&lt;/a</span><span class="k">&gt;:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">underlying</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="kc">null</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">None</span>
    <span class="k">case</span> <span class="n">value</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="o">}</span>
<span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">NotNothing</span><span class="o">[</span><span class="kt">A</span><span class="o">]{</span>
  <span class="k">type</span> <span class="kt">B</span>
<span class="o">}</span></code></pre></div></p>

<p>Our previous unbounded type argument is replaced with the new type class boundary of <code>NotNothing</code> and the runtime <code>Nothing</code> check is removed. We also need concrete instances of our type class, which is where the real magic comes into play.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">NotNothing</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">nothing</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NotNothing</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]{</span> <span class="k">type</span> <span class="kt">B</span> <span class="o">=</span> <span class="nc">Any</span> <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">notNothing</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">NotNothing</span><span class="o">[</span><span class="kt">A</span><span class="o">]{</span> <span class="k">type</span> <span class="kt">B</span> <span class="o">=</span> <span class="n">A</span> <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<p>Now, any application of <code>Nothing</code> will trigger the ambiguity problem – the Scala compiler won’t figure out how to resolve the type argument. This trick works because <code>Nothing</code> is at the <em>bottom</em> of Scala’s type hierarchy. Were I to call <code>getAs("balance")</code>, the Scala compiler would attempt to fill in <code>Nothing</code> as the type argument. However, both implicit conversons for <code>nothing</code> <em>and</em> <code>notNothing[A]</code> will match – causing ambiguity and compilation fails.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">doc</span><span class="o">.</span><span class="n">getAs</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;&amp;quot;foo&amp;quot;&quot;</span><span class="o">&gt;</span><span class="nc">String</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="cm">/* res0: Option[String] = Some(bar) &lt;em&gt;/</span>
<span class="cm">doc.getAs&lt;a href=&quot;&amp;quot;balance&amp;quot;&quot;&gt;Double&lt;/a&gt;</span>
<span class="cm">/&lt;/em&gt; res1: Option[Double] = Some(2.5) &lt;em&gt;/</span>
<span class="cm">doc.getAs(“balance”)</span>
<span class="cm">/&lt;/em&gt; error: ambiguous implicit values:</span>
<span class="cm"> both value nothing in object NotNothing of type =&amp;gt; java.lang.Object with com.mongodb.casbah.commons.NotNothing[Nothing]{type B = Any}</span>
<span class="cm"> and method notNothing in object NotNothing of type [A]=&amp;gt; java.lang.Object with com.mongodb.casbah.commons.NotNothing[A]{type B = A}</span>
<span class="cm"> match expected type com.mongodb.casbah.commons.NotNothing[A]</span>
<span class="cm">              doc.getAs(“balance”) </span>
<span class="cm">                       ^</span>
<span class="cm">*/</span></code></pre></div></p>

<p>A vast improvement in behavior, especially if we use the <a href="http://suereth.blogspot.com/2011/03/annotate-your-type-classes.html"><code>@implicitNotFound</code> annotation</a> to provide clear error messages.</p>

<p>The moral of the story – knowing the ins and outs of the type system and compiler corners can do great things for improving the functionality of your code. Especially being aware that as smart as the Scala compiler is, there are limitations inherent in the runtime platform (the JVM, specifically type erasure) that can make our lives difficult if ignored.</p>

<h2 id="update">Update</h2>

<p>While reviewing a draft of this post, <a href="http://twitter.com/djspiewak">Daniel Spiewak</a> noted one more issue with my code as it exists.  Namely, that we don’t have a sane way of preventing users from <em>miscasting</em>.  That is to say, if I try to fetch “balance” as a <code>String</code>, this shouldn’t be OK.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">doc</span><span class="o">.</span><span class="n">getAs</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;&amp;quot;balance&amp;quot;&quot;</span><span class="o">&gt;</span><span class="nc">String</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.</span><span class="n">getOrElse</span><span class="o">(</span><span class="kc">null</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ClassCastException</span><span class="k">:</span> <span class="kt">java.lang.Double</span> <span class="kt">cannot</span> <span class="kt">be</span> <span class="kt">cast</span> <span class="kt">to</span> <span class="kt">java.lang.String</span></code></pre></div></p>

<p>Daniel rightly points out how bad a runtime <code>ClassCastException</code> is, and has proposed another fix which I’m incorporating.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">getAs</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;key: String&quot;</span><span class="o">&gt;</span><span class="n">A</span> <span class="k">:</span> <span class="kt">NotNothing</span> <span class="kt">:</span> <span class="kt">Manifest&lt;/a</span><span class="k">&gt;:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">underlying</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="kc">null</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">None</span>
    <span class="k">case</span> <span class="n">value</span> <span class="k">if</span> <span class="n">manifest</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;:&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="nc">Manifest</span><span class="o">.</span><span class="n">classType</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">getClass</span><span class="o">)</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
      <span class="nc">Some</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
    <span class="k">case</span> <span class="n">fail</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> 
      <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="o">(</span><span class="err">“</span><span class="nc">Unable</span> <span class="n">to</span> <span class="n">cast</span> <span class="err">‘</span><span class="o">%</span><span class="n">s</span><span class="err">’</span> <span class="n">as</span> <span class="err">‘</span><span class="o">%</span><span class="n">s</span><span class="err">’</span><span class="o">;</span> <span class="n">please</span> <span class="n">check</span> <span class="n">your</span> <span class="n">types</span><span class="o">.</span><span class="err">”</span><span class="o">,</span> <span class="nc">Manifest</span><span class="o">.</span><span class="n">classType</span><span class="o">(</span><span class="n">fail</span><span class="o">.</span><span class="n">getClass</span><span class="o">),</span> <span class="n">manifest</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
      <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div></p>

<p>Now, when you ask for a type that doesn’t match what the Document contains, you will receive <code>None</code> and a warning in your log such as <code>Unable to cast 'java.lang.Double' as 'java.lang.String'; please check your types.</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Immutability and Clever Variable Usage in the Land of Blocks and Branches]]></title>
    <link href="http://bytes.codes/2011/08/05/ScalaPythonJavaCaptureBlockResult/"/>
    <updated>2011-08-05T00:00:00-07:00</updated>
    <id>http://bytes.codes/2011/08/05/ScalaPythonJavaCaptureBlockResult</id>
    <content type="html"><![CDATA[<p>Last night, I found myself unconciously refactoring some Scala code (I don’t recall if it was something I wrote or someone else did at this point). As I looked at what I was doing I realized that many Scala developers don’t seem entirely aware of one of my favorite features.  What I’m talking about is effectively capturing values from multibranch block statements in Scala.  Used correctly they can greatly decruft complicated code as well as helping us use mutability in places we might not expect an easy way to do so.</p>

<p>In typical C-like languages (such as C, C++, and Java) we are restricted in our syntax should we wish to capture a value when running many branching blocks such as if-else statements, switch statements and even for/foreach constructs. When we find ourselves wanting to set the value of a variable within each possible condition or iteration, we need to declare a mutable variable before the block.  We then mutate this variable within each condition or iteration.  Take this example from Java:</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">boolean</span> <span class="n">valid</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">valid</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">VALIDATED</span><span class="err">”</span><span class="o">;</span>
<span class="o">}</span> 
<span class="k">else</span> <span class="o">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">INVALID</span><span class="err">”</span><span class="o">;</span>
<span class="o">}</span></code></pre></div></p>

<!--more-->

<p>Not only have we had to declare a mutable value, but adding insult to injury the typical usage pattern includes declaring it as <code>null</code> (FACT: Everytime you explicitly use null, someone drowns a basket of adorable, whimpering puppies. Even if your language paradigm practically requires it.).  Within our if/else block we have established a new value for <code>status</code> based on the value of <code>valid</code>. Granted, this is a somewhat weak example of my point, as you could just as easily have expressed this in a more concise ternary statement:</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">?</span> <span class="err">“</span><span class="n">VALIDATED</span><span class="err">”</span> <span class="o">:</span> <span class="err">“</span><span class="n">INVALID</span><span class="err">”</span><span class="o">;</span></code></pre></div></p>

<p>This simplification breaks down quickly once our block becomes more complex.  Even the addition of a single <code>elseif</code> would eliminate the usefulness of the ternary syntax:</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// In this case, valid is now an int that can hold several states</span>
<span class="kt">int</span> <span class="n">valid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="cm">/* valid = SomeMethodCallThatReturnsValid() */</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">VALIDATED</span><span class="err">”</span><span class="o">;</span>
<span class="o">}</span> 
<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">INVALID</span><span class="err">”</span><span class="o">;</span> <span class="c1">// A simple not-valid indicator</span>
<span class="o">}</span> 
<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">UNINITIALIZED_ERROR</span><span class="err">”</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">else</span> <span class="o">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">UNKNOWN_ERROR</span><span class="err">”</span><span class="o">;</span>
<span class="o">}</span></code></pre></div></p>

<p>We’ve already bounced ourselves back to the land of <code>null</code> and forced mutability (can you hear those poor, helpless puppies trying to learn how to swim?). We will encounter similar (or potentially worse) limitations in the case of a for/foreach construct.</p>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">user</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">user</span><span class="o">&gt;();&lt;/</span><span class="n">user</span><span class="o">&gt;&lt;/</span><span class="n">user</span><span class="o">&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">for</span> <span class="o">(</span><span class="n">DBRow</span> <span class="n">row</span> <span class="o">:</span> <span class="n">databaseQuery</span><span class="o">(</span><span class="n">queryArgs</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">users</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nf">User</span><span class="o">(</span><span class="n">row</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="err">“</span><span class="n">username</span><span class="err">”</span><span class="o">),</span> <span class="n">row</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="err">“</span><span class="n">first_name</span><span class="err">”</span><span class="o">),</span> <span class="n">row</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="err">“</span><span class="n">last_name</span><span class="err">”</span><span class="o">));</span>
<span class="o">}</span></code></pre></div></p>

<p>Admittedly, this last block isn’t <em>that</em> bad, but it still irks me to <strong>have</strong> to declare a mutable list to facilitate it.  We probably could work around with a builder pattern but <strong>(a)</strong> as far as I know Java lacks a builtin List Builder and <strong>(b)</strong> We’d still probably be “building” a mutable list.</p>

<p>These paradigms obviously don’t restrict or limit everyone, but those of us who try to pay attention to immutability and the like start to grind our teeth awfully fast when encountering these patterns.  There has to be a better way, right?  How do other languages handle these constructs and related problems?</p>

<h2 id="the-pythonic-way">The Pythonic Way</h2>
<p>For those that know Python — a language that I have long loved, and using Scala has only reinforced that as I learn &amp; understand more of the FP goodness in Python — there are some nice tricks to alleviate the previously demonstrated pain (and save those puppies).  Unfortunately, some of these tricks also stink a bit too much like syntactic magic; I tend to think at least one of them violates Python’s “explicit over implicit” rules too.</p>

<p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Again, valid is now an int that can hold several states</span>
<span class="n">valid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;/*</span> <span class="n">valid</span> <span class="o">=</span> <span class="n">some_method_to_set_valid</span><span class="p">()</span> <span class="o">*/&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span> <span class="n">valid</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">VALIDATED</span><span class="err">”</span>
<span class="k">elif</span> <span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">INVALID</span><span class="err">”</span>
<span class="k">elif</span> <span class="n">valid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">UNINITIALIZED_ERROR</span><span class="err">”</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">status</span> <span class="o">=</span> <span class="err">“</span><span class="n">UNKNOWN_ERROR</span><span class="err">”</span></code></pre></div></p>

<p>Here’s that magic I’m talking about — despite us not explicitly declaring/initializing it, Python will instantiate a variable <code>status</code> at the <em>outer</em> scope (that is to say, outside of our if-else block).  This is incredibly useful for cutting down line noise related to unecessary declaration of variables; unfortunately it is also a common confusion point for beginning Pythonistas.</p>

<pre><code>*"Where the hell did this `status` variable come from? It wasn't ever declared in an outer scope!"*
</code></pre>

<p>While we’ve avoided initializing <code>status</code> to null, we still encounter the pesky mutability issue.  We ultimately ended up with a variable <code>status</code> which can be mutated later.  This isn’t ideal, but as far as I know Python has no way to enable/enforce immutable state.</p>

<p>Python also can take us closer to an ideal state with the for/foreach constructs.  My big gripe with the previous Java for loop code was the need to declare a mutable <code>List</code> and incrementally add to it.  Python has a cure for what ails us here, in the form of generators — a feature which, as you’ll see, I’d give my left pinkie (or maybe just the last millimeter of my left pinkie nail) to have in Scala as well.</p>

<p>Here’s how a smart Pythonista might express our database processing loop in a way that limits the declaration of mutable variables:</p>

<p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">process_dbusers</span><span class="p">(</span><span class="n">dbResults</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">dbResults</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">User</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="err">‘</span><span class="n">username</span><span class="err">’</span><span class="p">),</span> <span class="n">row</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="err">‘</span><span class="n">first_name</span><span class="err">’</span><span class="p">),</span> 
                   <span class="n">row</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="err">‘</span><span class="n">last_name</span><span class="err">’</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">users</span> <span class="o">=</span> <span class="n">process_dbusers</span><span class="p">(</span><span class="n">db_query</span><span class="p">(</span><span class="n">query_args</span><span class="p">))</span></code></pre></div></p>

<p>With this code, we’ve already quickly wandered into the land of “Things Java Can’t Even Pretend To Do” here (which I think highlights my amusement at people arguing Java’s power over Python.  It’s all relative when you know the right syntax … ).  To best handle this expression we’ve constructed a higher- order function <code>process_dbusers</code>, which takes in a database results iterator, returning a list-like construct with the results.  I want to emphasize the term <em>list-like</em> here because what we got is not, in fact, a list (rather it is “Iterable”).  A quick peek at the REPL (if you don’t already have <a href="http://ipython.org">IPython</a> you are really missing out) evinces this:</p>

<p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">users</span>
<span class="c"># &amp;lt;generator object process_db at 0x10ca93690&amp;gt;&lt;/p&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nb">type</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
<span class="c"># &amp;lt;type ‘generator’&amp;gt;</span></code></pre></div></p>

<p>Python supports a special type of expression (which again, I’d love to have in Scala and have been playing with ways to support) called a <em>generator</em>.  In addition to being immutable, a generator is also lazy; it does not evaluate the entire list at creation, instead evaluating each member as it is first read (notably though, Python generators do not memoize and cannot be iterated repeatedly).  Note that Python’s <code>yield</code> keyword differs from Scala’s; it may be easiest to think of it as a “super-return” or “return on crack” in that it actually suspends execution (via coroutines) after returning <em>each</em> value.</p>

<p>The ‘generator’ produced is actually an iterable value; requesting the ‘next’ item resumes execution, runs the next iteration of the internal for loop again, yields the return value and suspends again.  Not only is this generator value immutable, but it should be significantly more efficient in many cases; if we don’t need to store each <code>User</code> but process them as we read them, we should see a lot better resource usage.</p>

<p>There is one other way to express the previous statement without needing a nested function set or the ‘yield’ keyword, using “generator expressions”.  The downside to the <code>yield</code> based generators is that they must be wrapped inside another function, making them messy to inline with other code. With Generator Expressions we can get the same behavior in a compact, inline one-liner.  A Generator Expression is syntactically identical to a Python <a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions">List Comprehension</a> with one key difference:  You must enclose the expression in parentheses ( <code>(</code> and <code>)</code> ) instead of square brackets ( <code>[</code> and <code>]</code>).  While a List Comprehension will return a list, enclosing that same statement in parentheses instead of brackets will produce a generator. This Generator Expression works as if we had written a multiline <code>for</code> construct with <code>yield</code>:</p>

<p><div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Define a tuple of test values</span>
<span class="n">items</span> <span class="o">=</span> <span class="p">(</span><span class="err">‘</span><span class="n">Foo</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">bar</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">Baz</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">spam</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">eggs</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">apples</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">oranges</span><span class="err">’</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">h1</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;use-a-list-comprehension-returns-a-list&quot;</span><span class="o">&gt;</span><span class="n">Use</span> <span class="n">a</span> <span class="n">List</span> <span class="n">Comprehension</span><span class="p">,</span> <span class="n">returns</span> <span class="n">a</span> <span class="nb">list</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">itemList</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
<span class="c"># [‘Foo’, ‘bar’, ‘Baz’, ‘spam’, ‘eggs’, ‘apples’, ‘oranges’]</span>
<span class="c"># Use a Generator Expression which returns a generator</span>
<span class="n">itemGen</span>  <span class="o">=</span> <span class="p">(</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">)</span>
<span class="c"># &amp;lt;generator object &lt;genexpr&gt; at 0x10cafa050&amp;gt;&lt;/genexpr&gt;&lt;/p&gt;</span>

<span class="o">&lt;</span><span class="n">h1</span> <span class="nb">id</span><span class="o">=</span><span class="s">&quot;you-can-also-filter-these-expressions&quot;</span><span class="o">&gt;</span><span class="n">You</span> <span class="n">can</span> <span class="n">also</span> <span class="nb">filter</span> <span class="n">these</span> <span class="n">expressions</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c"># Return a list which filters to return only items which are ‘food’</span>
<span class="n">foodList</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">(</span><span class="err">‘</span><span class="n">spam</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">eggs</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">apples</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">oranges</span><span class="err">’</span><span class="p">)]</span>
<span class="c"># [‘spam’, ‘eggs’, ‘apples’, ‘oranges’]</span>
<span class="c"># The same filter, but as a generator expression</span>
<span class="n">foodGen</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">(</span><span class="err">‘</span><span class="n">spam</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">eggs</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">apples</span><span class="err">’</span><span class="p">,</span> <span class="err">‘</span><span class="n">oranges</span><span class="err">’</span><span class="p">))</span>
<span class="c"># &amp;lt;generator object &lt;genexpr&gt; at 0x10cafa140&amp;gt;</span>
<span class="c"># Generators are iterable ...</span>
<span class="n">foodGen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="c"># &#39;spam&#39;</span>
<span class="n">foodGen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="c"># &#39;eggs&#39;</span></code></pre></div></genexpr></p>

<p>We’ve certainly, on the Python side, gotten closer to a world which can exist without unecessary variable initialization and sane immutability… but aren’t entirely where I’d like to be.  To understand things better let’s look, finally, at what Scala lets us do.</p>

<h2 id="the-scala-way">The Scala Way</h2>

<p>A rough take on the code I was optimizing last night can be used to highlight the power of Scala’s way of solving the kinds of problems we are discussing.  Here’s a Scala version of our if-elseif-else construct from Java:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">valid</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">someMethodCallThatSetsValidity</span><span class="o">()&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">var</span> <span class="n">status</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// ack, mutable &lt;em&gt;and&lt;/em&gt; null inited - A scala programmer’s worst nightmare&lt;/p&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">status</span> <span class="k">=</span> <span class="err">“</span><span class="nc">VALIDATED</span><span class="err">”</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">status</span> <span class="k">=</span> <span class="err">“</span><span class="nc">INVALID</span><span class="err">”</span> 
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">status</span> <span class="k">=</span> <span class="err">“</span><span class="nc">UNINITIALIZED_ERROR</span><span class="err">”</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span> 
  <span class="n">status</span> <span class="k">=</span> <span class="err">“</span><span class="nc">UNKNOWN_ERROR</span><span class="err">”</span>
<span class="o">}</span></code></pre></div></p>

<p>There are lots of things that are egregious here from the eyes of an experienced Scala programmer, but it is also pretty close to the style I would expect from a fairly new Scala programmer.  There is of course a <em>much</em> better way to do this in Scala without any magic tricks.</p>

<p>One of the cool little edge behaviors of Scala’s syntax is the ability to capture the return value of most block statements — even if-else statements.  This lends itself to quickly shortening our code <em>and</em> enforcing immutability on the final value of status.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">valid</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">someMethodCallThatSetsValidity</span><span class="o">()&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">status</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> 
  <span class="err">“</span><span class="nc">VALIDATED</span><span class="err">”</span> <span class="c1">// returns “VALIDATED”</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="err">“</span><span class="nc">INVALID</span><span class="err">”</span>  <span class="c1">// returns “INVALID”</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="err">“</span><span class="nc">UNINITIALIZED_ERROR</span><span class="err">”</span> <span class="c1">// returns “UNINITIALIZED_ERROR”</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span> 
  <span class="err">“</span><span class="nc">UNKNOWN_ERROR</span><span class="err">”</span> <span class="c1">// returns “UNKNOWN_ERROR”</span>
<span class="o">}</span></code></pre></div></p>

<p>Much better! The way that Scala evaluates this code, you can think of each branch of the block (the body of each “if”, “else if” and “else” statements) as an anonymous function.  Because it is evaluated this way, Scala allows us to return values, which can be captured from the entire block (The use of the explicit <code>return</code> keyword is typically considered bad form in Scala which is why it is omitted here).  If <code>valid</code> has a value of <code>1</code>, this block will return <code>"VALIDATED"</code>.</p>

<p>The type of <code>safe</code> in this code will be inferred to <code>String</code>, because each branch returns a <code>String</code>. Although in Scala it is usually recommended to let type inference do its work wherever possible and avoid explicit type annotations, variables capturing values from a block like this might be a good exception to the rule.</p>

<p>The argument that I make is that if the type inference system finds multiple <em>differing</em> types in each branch, it will search backwards on the type hierarchies for the closest “ancestor” type of each type.  This can quickly lead to the type of <code>status</code> being something far too generic (or even unexpected in the case of a bug).</p>

<p>We can see this quickly by changing the return of our <code>else</code> branch to a boolean:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">status</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> 
  <span class="err">“</span><span class="nc">VALIDATED</span><span class="err">”</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="err">“</span><span class="nc">INVALID</span><span class="err">”</span> 
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="err">“</span><span class="nc">UNINITIALIZED_ERROR</span><span class="err">”</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span> 
  <span class="kc">false</span> 
<span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;/*</span> <span class="nc">Turn</span> <span class="n">on</span> <span class="err">“</span><span class="nc">Power</span> <span class="nc">Mode</span><span class="err">”</span> <span class="n">in</span> <span class="n">the</span> <span class="n">repl</span> <span class="n">to</span> <span class="n">dump</span> <span class="n">the</span> <span class="k">type</span> <span class="o">(</span><span class="kt">:power</span><span class="o">)</span> 
<span class="kt">scala&amp;gt</span><span class="o">;</span> <span class="k">:type</span> <span class="kt">status</span>
<span class="nc">Any</span>
<span class="o">*/</span></code></pre></div></p>

<p>This is not good, and often will result in a bug.  If you were expecting <code>String</code>, you will be sorely disappointed. The easiest fix to this is to explicitly annotate an expected return type, which forces the compiler to help you enforce expectations:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">status</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> 
  <span class="err">“</span><span class="nc">VALIDATED</span><span class="err">”</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="err">“</span><span class="nc">INVALID</span><span class="err">”</span> 
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">valid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="err">“</span><span class="nc">UNINITIALIZED_ERROR</span><span class="err">”</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span> 
  <span class="kc">false</span> 
<span class="o">}</span>
<span class="cm">/* Fails to compile!&lt;/p&gt;</span>
<span class="cm">&lt;console&gt;:29: error: type mismatch;</span>
<span class="cm"> found   : Boolean(false)</span>
<span class="cm"> required: String</span>
<span class="cm">         false </span>

<span class="cm">*/</span></code></pre></div>

We can also easily simplify this whole block into a pattern match, which will read more clearly in Scala.  Fortuitously, Scala also lets us capture the return values from `match` blocks, following the same rules (including the Type Annotation concerns) as in if-else.

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">annotation.switch</span>

<span class="c1">// Even better, cut out one more variable storage by calling our valid check inline</span>
<span class="k">val</span> <span class="n">status</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">(</span><span class="n">someMethodCallThatSetsValidity</span><span class="o">()</span><span class="k">:</span> <span class="kt">@switch</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span>  <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="s">&quot;VALIDATED&quot;</span>
    <span class="k">case</span> <span class="mi">0</span>  <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="s">&quot;INVALID&quot;</span>
    <span class="k">case</span> <span class="o">-</span><span class="mi">1</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="s">&quot;UNINITIALIZED_ERROR&quot;</span>
    <span class="k">case</span> <span class="n">default</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="s">&quot;UNKNOWN_ERROR&quot;</span>
<span class="o">}</span></code></pre></div>

*The use of the @switch annotation is a trick I learned from [Josh Suereth&#8217;s](http://suereth.blogspot.com/) absolutely superb book [Scala in Depth](http://www.manning.com/suereth/); when used with certain matches (they typically need to match numeric values) they ensure the compiler generates a much more efficient JVM bytecode for the match execution/evaluation.*

I&#8217;ll leave the evaluation of that last as an exercise for the reader.  Fundamentally it is a simple restatement of our previous if-else blocks and should make sense.

Now that we&#8217;ve looked at branching block statements and value capture in Scala, we&#8217;re left with one last item — for constructs (We aren&#8217;t going to discuss monad operators such as `foreach`, `map`, `flatmap`, etc here). 

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">42</span><span class="o">)</span> <span class="n">x</span>
<span class="c1">// Loops 42 times, but returns / prints nothing</span></code></pre></div>

Unlike other the previously examined branching blocks (if-else and matches), Scala&#8217;s `for` loops do *not* implicitly return the last value.  I would make an educated guess that this is because most developers would not expect or require the default behavior of a `for` loop to generate return values.  I&#8217;d also go so far as to posit that this is a very sane default. 

Much like Python, to generate a return value from a `for` loop in Scala we must explicitly declare our intention to return a value. While (as I lamented previously) Scala lacks support for Python style generators, it does support a form of List Comprehensions which allow us to get the behavior we want.  For a Python developer, the rules for constructing these in Scala may get quickly confusing.  The first is that `return` is not a valid keyword at *all* inside of a Scala `for` statement (Incidentally, Python allows it as a &#8216;valid&#8217; keyword, but the function will always return the result of the first loop iteration and never progress).

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">42</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span>
<span class="cm">/* Fails to compile </span>
<span class="cm">&lt;console&gt;:29: error: return outside method definition</span>
<span class="cm">       for (x &amp;lt;- 1 until 42) return x </span>
<span class="cm">*/</span></code></pre></div>

Instead, we need to use a special keyword, `yield`, to signify our intention to create a List Comprehension rather than a simple loop.  Like in Python, `yield` changes the behavior of a `for` loop.  However, the behavior of the `yield` keyword in Scala differs significantly from Python, as it does not invoke generator behavior.  The use of `yield` inside a Scala `for` loop will produce results along the lines of those of Python&#8217;s square bracket enclosed List Comprehensions:

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">42</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span>
<span class="cm">/* scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42)</span>
<span class="cm">*/</span></code></pre></div>

The output of the `for` loop which uses `yield` will always be an *immutable* `Seq[_]`, letting us save that result for later usage much like we did with our Python generators and comprehensions.  And of course, Scala&#8217;s `for` loops allow for filters just like Python&#8217;s:

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">items</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="s">&quot;baz&quot;</span><span class="o">,</span> <span class="s">&quot;spam&quot;</span><span class="o">,</span> <span class="s">&quot;eggs&quot;</span><span class="o">,</span> <span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">itemList</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">item</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">items</span><span class="o">)</span> <span class="k">yield</span> <span class="n">item</span>
<span class="cm">/* itemList: List[java.lang.String] = List(foo, bar, baz, spam, eggs, apples, oranges) */</span>

<span class="k">val</span> <span class="n">foodList</span> <span class="k">=</span> 
    <span class="k">for</span> <span class="o">(</span><span class="n">item</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">items</span> <span class="k">if</span> <span class="s">&quot;spam&quot;</span> <span class="o">::</span> <span class="s">&quot;eggs&quot;</span> <span class="o">::</span> <span class="s">&quot;apples&quot;</span> <span class="o">::</span> <span class="s">&quot;oranges&quot;</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="n">contains</span> <span class="n">item</span><span class="o">)</span> 
        <span class="k">yield</span> <span class="n">item</span>
<span class="cm">/* foodList: List[java.lang.String] = List(spam, eggs, apples, oranges) */</span>

<span class="c1">// We can also expand that for comprehension into the alternate syntax for clarity</span>
<span class="k">val</span> <span class="n">expandedFoodList</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">item</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">items</span>
  <span class="k">if</span> <span class="s">&quot;spam&quot;</span> <span class="o">::</span> <span class="s">&quot;eggs&quot;</span> <span class="o">::</span> <span class="s">&quot;apples&quot;</span> <span class="o">::</span> <span class="s">&quot;oranges&quot;</span> <span class="o">::</span> <span class="nc">Nil</span> <span class="n">contains</span> <span class="n">item</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">item</span>

<span class="c1">// expandedFoodList: List[java.lang.String] = List(spam, eggs, apples, oranges)</span></code></pre></div>


The intention here wasn&#8217;t to &#8220;bash&#8221; on Java or even champion Python or Scala; rather, to highlight the ways that different syntactic features add power, flexiblity and (in the case of things like mutability) potential safety to our code.  Though I&#8217;m accused of being a Scala fanboy, I want to clearly reiterate generators as something that I still think Python gets as a *major* edge over Scala.  I work in all three of the highlighted languages on a daily basis and though I probably enjoy Java the least, find gems and strengths in each tool as I switch between them (to be honest though, most of Java&#8217;s gems these days exist in the JVM and the JDK libraries rather than the language).

It may easily be said that I am biased, but I consider the improved functionality highlighted in Python and Scala to be significantly more powerful (and yet less complex in many ways) than Java&#8217;s approach.  Mutating variables, null initializations and general spaghetti code for the sake of expressing something that should be simpler to express are all things that lead to workplace violence and big bonus checks for employees of straight jacket manufacturers. 

With our improved examples in Scala, we didn&#8217;t need to create any mutable placeholder values, initialize anything to `null` *or* worry about ending up with a still mutable list to contend with.  What we got was a pure, unadulterated, cleanly constructed immutable `Seq`, just like grandmom used to bake! And it smells freaking *delicious*.

-b 
</console></console>
]]></content>
  </entry>
  
</feed>
