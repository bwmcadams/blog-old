<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: functionalprogramming | Bytes.Codes]]></title>
  <link href="http://bytes.codes/categories/functionalprogramming/atom.xml" rel="self"/>
  <link href="http://bytes.codes/"/>
  <updated>2015-08-23T18:50:10-07:00</updated>
  <id>http://bytes.codes/</id>
  <author>
    <name><![CDATA[Brendan McAdams]]></name>
    <email><![CDATA[brendan@bytes.codes]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Skeptic's Guide to Scalaz' Gateway Drugs: Part 2 - Options with Disjunction]]></title>
    <link href="http://bytes.codes/2015/04/13/a-skeptics-guide-to-scalaz-gateway-drugs-part-2-options-with-disjunction/"/>
    <updated>2015-04-13T12:14:44-07:00</updated>
    <id>http://bytes.codes/2015/04/13/a-skeptics-guide-to-scalaz-gateway-drugs-part-2-options-with-disjunction</id>
    <content type="html"><![CDATA[<p><em>(This is Part 2 of a series of distillations of a presentation I’ve been giving for the last year, <a href="http://slides.com/bwmcadams/scalaz-gateway-drugs">“A Skeptic’s Guide to scalaz’ Gateway Drugs”</a>. It is meant to provide an introduction to the core functionality of scalaz that a developer might find most useful, without going off the deep end. Previous entries include <a href="/2015/04/10/a-skeptics-guide-to-scalaz-part-1-disjunctions/">Part 1 – Disjunctions</a>)</em></p>

<p>Welcome back to the Skeptic’s Guide to <code>scalaz</code>. In <a href="/2015/04/10/a-skeptics-guide-to-scalaz-part-1-disjunctions/">the last part</a> of this series, we introduced you to the power of <code>scalaz</code> Disjunctions—also known as <code>\/</code>—and how we can use them to indicate a return value of <em>either</em> an Error or a Success. As a reminder, convention dictates that Left—<code>-\/</code>—is an error, while Right—<code>\/-</code>—is success.</p>

<p><img src="/images/buck-phone.gif" alt="Hello? scalaz?" /></p>

<p>In this part, we’ll discuss interactions with Scala’s <code>Option</code>. Specifically, I want to discuss how to manage “stacks” of <code>Option</code> in for comprehensions, and how to use Disjunction to manage them.</p>

<!--more-->

<p>In Scala, <code>Option</code> is a container commonly used to indicate a return type that can have no value. <code>Option</code> has two subtypes: <code>Some[T]</code>—which contains a value of type <code>T</code>—and <code>None</code>, which contains no value. We use these in the Scala world to avoid the sins of <code>null</code>; Because <code>None</code> is a valid object, invoking functions on it doesn’t cause the dreaded <code>NullPointerException</code>.</p>

<p>Similar to <code>scalaz</code> Disjunctions, there is a “Right” bias on <code>Option</code>. Specifically, it is biased towards <code>Some[T]</code>, and when we comprehend over <code>Some[T]</code> the loop continues:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno"> 1</span> <span class="k">val</span> <span class="n">some1</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="err">“</span><span class="nc">This</span> <span class="n">is</span> <span class="n">a</span> <span class="n">value</span><span class="o">.</span><span class="err">”</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">some2</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="err">“</span><span class="nc">This</span> <span class="n">is</span> <span class="n">also</span> <span class="n">a</span> <span class="n">value</span><span class="o">.</span><span class="err">”</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">some3</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="err">“</span><span class="nc">You</span> <span class="n">guessed</span> <span class="n">it</span><span class="o">.</span> <span class="n">A</span> <span class="n">value</span><span class="err">”</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">for</span> <span class="o">{</span>
<span class="lineno"> 8</span>   <span class="n">one</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">some1</span>
<span class="lineno"> 9</span>   <span class="n">two</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">some2</span>
<span class="lineno">10</span>   <span class="n">three</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">some3</span> 
<span class="lineno">11</span> <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">two</span><span class="o">,</span> <span class="n">three</span><span class="o">)</span>
<span class="lineno">12</span> <span class="cm">/* res2: Option[(String, String, String)] = </span>
<span class="lineno">13</span> <span class="cm">    Some((This is a value.,This is also a value.,You guessed it. A value)) */</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">14</span> 
<span class="lineno">15</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>As I said, <code>Option</code> has a bias towards <code>Some</code>. Each step of the comprehension here unpacks a value from <code>Some</code>. But what if there’s a <code>None</code> thrown in there?</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno"> 1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">for</span> <span class="o">{</span>
<span class="lineno"> 4</span>   <span class="n">one</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">some1</span>
<span class="lineno"> 5</span>   <span class="n">two</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="nc">None</span>
<span class="lineno"> 6</span>   <span class="n">three</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">some3</span>
<span class="lineno"> 7</span> <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">two</span><span class="o">,</span> <span class="n">three</span><span class="o">)</span>
<span class="lineno"> 8</span> <span class="cm">/* res3: Option[(String, Nothing, String)] = None */</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>What went wrong? In short, the same behavior as we saw when we threw a Left Disjunction into a comprehension. When we encounter a <code>None</code>, the loop aborts and returns the failure value. For a deeper look at what I mean—and how to fix it—let’s construct some more concrete sample data.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno"> 1</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Address</span><span class="o">(</span><span class="n">city</span><span class="k">:</span> <span class="kt">String</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">first</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> 
<span class="lineno"> 4</span>                 <span class="n">last</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> 
<span class="lineno"> 5</span>                 <span class="n">address</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Address</span><span class="o">])&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">case</span> <span class="k">class</span> <span class="nc">DBObject</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> 
<span class="lineno"> 8</span>                     <span class="n">user</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">])&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">brendan</span> <span class="k">=</span> 
<span class="lineno">11</span>   <span class="nc">Some</span><span class="o">(</span><span class="nc">DBObject</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">User</span><span class="o">(</span><span class="err">“</span><span class="nc">Brendan</span><span class="err">”</span><span class="o">,</span> <span class="err">“</span><span class="nc">McAdams</span><span class="err">”</span><span class="o">,</span> <span class="nc">None</span><span class="o">))))&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">someOtherGuy</span> <span class="k">=</span> 
<span class="lineno">14</span>   <span class="nc">Some</span><span class="o">(</span><span class="nc">DBObject</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">None</span><span class="o">))</span></code></pre></div></p>

<p>Here is a set of constructs that will let us represent a user &amp; address in our database. Note that both <code>User</code> and <code>Address</code> are optional on their respective containers. I’ve seen a lot of code that works this way: “If the database failed to return a row, let’s return <code>None</code>”. Here’s what it looks like in practice when one of those row retrievals fails…</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">for</span> <span class="o">{</span>
<span class="lineno">2</span>   <span class="n">dao</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">brendan</span>
<span class="lineno">3</span>   <span class="n">user</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">dao</span><span class="o">.</span><span class="n">user</span>
<span class="lineno">4</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">user</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">5</span> 
<span class="lineno">6</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;/*</span> <span class="n">res4</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">User</span><span class="o">(</span><span class="nc">Brendan</span><span class="o">,</span><span class="nc">McAdams</span><span class="o">,</span><span class="nc">None</span><span class="o">))</span> <span class="o">*/&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">7</span> 
<span class="lineno">8</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>In our first example, <code>brendan</code> is a <code>DBObject</code> with a valid <code>User</code>. When we comprehend over just the <code>DBObject</code> and <code>User</code>, we get back a valid <code>Some</code>. But what if we try to extract both the <code>User</code> and <code>Address</code> from <code>someOtherGuy</code>?</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">for</span> <span class="o">{</span>
<span class="lineno">2</span>   <span class="n">dao</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">someOtherGuy</span>
<span class="lineno">3</span>   <span class="n">user</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">dao</span><span class="o">.</span><span class="n">user</span>
<span class="lineno">4</span>   <span class="n">address</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">user</span><span class="o">.</span><span class="n">address</span>
<span class="lineno">5</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span>
<span class="lineno">6</span> <span class="cm">/* res5: Option[Address] = None */</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">7</span> 
<span class="lineno">8</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>Now, if we were retrieving the data from the database we’ve run up against a very interesting question. Was there no <code>User</code>? Or was there no <code>Address</code>? This is the problem I ran into a <em>lot</em> with returning <code>Option</code> from the database.</p>

<p><img src="/images/majorKong.gif" alt="Boom!" /></p>

<p>Fundamentally, comprehending over groups of <code>Option</code> leads to “silent failure”. Luckily, <code>scalaz</code> includes some implicits to convert an <code>Option</code> to a Disjunction. Since Disjunction’s right bias makes it easy to comprehend, we can do the conversion in place without rewriting a lot of code. For a Left, we’ll still get useful information in place of <code>None</code>.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="nc">None</span><span class="o">.</span><span class="n">toRightDisjunction</span><span class="o">(</span><span class="err">“</span><span class="nc">No</span> <span class="k">object</span> <span class="nc">found</span><span class="err">”</span><span class="o">)</span>
<span class="lineno">2</span> <span class="cm">/* res6: scalaz.\/[String,Nothing] = -\/(No object found) */</span></code></pre></div></p>

<p>Here, we call the implicit function <code>toRightDisjunction</code> upon an instance of <code>Option</code> (<code>None</code>, in this case). Specifically, <code>toRightDisjunction</code> says “Convert an <code>Option</code> to a disjunction where <code>Some[T]</code> becomes <code>\/-(T)</code>—Right—and <code>None</code> becomes <code>-\/(&lt;argument&gt;)</code>”, or Left. That last bit is important: the argument to <code>toRightDisjunction</code> is used to create a value for a Left Disjunction.</p>

<p>For those who prefer ‘concise’ over ‘explicit’, there is also a symbolic version of <code>toRightDisjunction</code>, which is functionally identical:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="nc">None</span> <span class="o">\/&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">No</span> <span class="k">object</span> <span class="nc">found</span><span class="err">”</span>
<span class="lineno">2</span> <span class="cm">/* res7: scalaz.\/[String,Nothing] = -\/(No object found) */</span></code></pre></div></p>

<p>So, when there’s a <code>None</code> we use the argument to <code>toRightDisjunction</code> to create a <code>-\/</code>, but if there’s a <code>Some</code> we convert the value from <code>Some[T]</code> to <code>\/-[T]</code>. Here’s what it looks like with <code>Some</code> values:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="nc">Some</span><span class="o">(</span><span class="err">“</span><span class="nc">My</span> <span class="nc">Hovercraft</span> <span class="nc">Is</span> <span class="nc">Full</span> <span class="n">of</span> <span class="nc">Eels</span><span class="err">”</span><span class="o">)</span> <span class="o">\/&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">No</span> <span class="k">object</span> <span class="nc">found</span><span class="err">”</span>
<span class="lineno">2</span> <span class="cm">/* res8: scalaz.\/[String, String] = \/-(My Hovercraft Is Full of Eels) */</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">3</span> 
<span class="lineno">4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nc">Some</span><span class="o">(</span><span class="err">“</span><span class="n">I</span> <span class="nc">Will</span> <span class="nc">Not</span> <span class="nc">Buy</span> <span class="nc">This</span> <span class="nc">Record</span> <span class="nc">It</span> <span class="nc">Is</span> <span class="nc">Scratched</span><span class="err">”</span><span class="o">)</span>
<span class="lineno">5</span>   <span class="o">.</span><span class="n">toRightDisjunction</span><span class="o">(</span><span class="err">“</span><span class="nc">No</span> <span class="k">object</span> <span class="nc">found</span><span class="err">”</span><span class="o">)</span>
<span class="lineno">6</span> <span class="cm">/* res9: scalaz.\/[String, String] = </span>
<span class="lineno">7</span> <span class="cm">  \/-(I Will Not Buy This Record, It Is Scratched”) */</span></code></pre></div></p>

<p>Given these new tools, let’s look at that user/address extraction again.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno"> 1</span> <span class="k">for</span> <span class="o">{</span>
<span class="lineno"> 2</span>   <span class="n">dao</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">brendan</span> <span class="o">\/&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">No</span> <span class="n">user</span> <span class="n">by</span> <span class="n">that</span> <span class="nc">ID</span><span class="err">”</span>
<span class="lineno"> 3</span>   <span class="n">user</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">dao</span><span class="o">.</span><span class="n">user</span> <span class="o">\/&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">Join</span> <span class="n">failed</span><span class="k">:</span> <span class="kt">no</span> <span class="kt">user</span> <span class="kt">object</span><span class="err">”</span>
<span class="lineno"> 4</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">user</span>
<span class="lineno"> 5</span> <span class="cm">/* res10: scalaz.\/[String,User] = \/-(User(Brendan,McAdams,None)) */</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">for</span> <span class="o">{</span>
<span class="lineno"> 8</span>   <span class="n">dao</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">someOtherGuy</span> <span class="o">\/&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">No</span> <span class="n">user</span> <span class="n">by</span> <span class="n">that</span> <span class="nc">ID</span><span class="err">”</span>
<span class="lineno"> 9</span>   <span class="n">user</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">dao</span><span class="o">.</span><span class="n">user</span> <span class="o">\/&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">Join</span> <span class="n">failed</span><span class="k">:</span> <span class="kt">no</span> <span class="kt">user</span> <span class="kt">object</span><span class="err">”</span>
<span class="lineno">10</span>   <span class="kt">address</span> <span class="kt">&amp;lt</span><span class="o">;-</span> <span class="n">user</span><span class="o">.</span><span class="n">address</span> <span class="o">\/&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">Join</span> <span class="n">failed</span><span class="k">:</span> <span class="kt">No</span> <span class="kt">address</span> <span class="kt">on</span> <span class="kt">user</span><span class="err">”</span>
<span class="lineno">11</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">address</span>
<span class="lineno">12</span> <span class="cm">/* res11: scalaz.\/[String,Address] = -\/(Join failed: no user object) */</span></code></pre></div></p>

<p>Hey, look at that! On our second comprehension, we got some useful information back about what went wrong. Now we can log that, return it to the frontend, or whatever else it is you do with failure data.</p>

<p>What if we want to do something beyond comprehensions? Stay tuned for our next episode, where we’ll talk about <code>Validation</code>, and how to use it to check multiple error conditions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Skeptic's Guide to scalaz' Gateway Drugs: Part 1 - Disjunctions]]></title>
    <link href="http://bytes.codes/2015/04/10/a-skeptics-guide-to-scalaz-part-1-disjunctions/"/>
    <updated>2015-04-10T15:41:37-07:00</updated>
    <id>http://bytes.codes/2015/04/10/a-skeptics-guide-to-scalaz-part-1-disjunctions</id>
    <content type="html"><![CDATA[<p><em>(This is Part 1 of a series of distillations of a presentation I’ve been giving for the last year, <a href="http://slides.com/bwmcadams/scalaz-gateway-drugs">“A Skeptic’s Guide to scalaz’ Gateway Drugs”</a>. It is meant to provide an introduction to the core functionality of scalaz that a developer might find most useful, without going off the deep end.)</em></p>

<p>What is <code>scalaz</code> exactly? Well, at its core, <code>scalaz</code> is a functional programming library for Scala. It is intended to bring more functional programming concepts from languages like Haskell into Scala.</p>

<p>Until recently, I’ve looked at <a href="https://github.com/scalaz/scalaz">scalaz</a> rather skeptically. As a self taught developer without any college or advanced mathematics training, I felt intimidated by what I saw. Long before I exited the ranks of rookie Scala programmer, I dabbled in Haskell a bit but left more confused than I started at.</p>

<p><img src="/images/clockwork-eyes.gif" alt="" /></p>

<p>So, tools like <code>scalaz</code> were a bit scary to me. Plus, “what’s wrong with the Scala standard library?”. As it turns out, a lot. Let’s look first at Scala’s Either, and where we can improve upon it.
<!--more-->
Scala’s builtin <a href="http://www.scala-lang.org/api/current/#scala.util.Either">Either</a> is a common construct used to indicate one of two conditions: Success or Error. These are, by convention, <code>Left</code> for Errors, and <code>Right</code> for Success. The concept is good, but there are some limits to interaction. By default, we cannot use it in a for comprehension:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno"> 1</span> <span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="k">val</span> <span class="n">success</span> <span class="k">=</span> <span class="nc">Right</span><span class="o">(</span><span class="err">“</span><span class="nc">Success</span><span class="o">!</span><span class="err">”</span><span class="o">)</span>
<span class="lineno"> 2</span> <span class="n">success</span><span class="k">:</span> <span class="kt">scala.util.Right</span><span class="o">[</span><span class="kt">Nothing</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Right</span><span class="o">(</span><span class="nc">Success</span><span class="o">!)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">success</span><span class="o">.</span><span class="n">isRight</span>
<span class="lineno"> 5</span> <span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">success</span><span class="o">.</span><span class="n">isLeft</span>
<span class="lineno"> 8</span> <span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="k">for</span> <span class="o">{</span>
<span class="lineno">11</span>        <span class="o">|</span>   <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">success</span>
<span class="lineno">12</span>        <span class="o">|</span> <span class="o">}</span> <span class="k">yield</span> <span class="n">x</span>
<span class="lineno">13</span>        <span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">map</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">scala.util.Right</span><span class="o">[</span><span class="kt">Nothing</span>,<span class="kt">String</span><span class="o">]</span>
<span class="lineno">14</span>                       <span class="n">x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">success</span>
<span class="lineno">15</span>                            <span class="o">^</span></code></pre></div></console></p>

<p><em>(Note, there is a function called <code>rightProjection</code> which converts an <code>Either</code> into something comprehendable)</em></p>

<p>In the <code>scalaz</code> world, there is a similar construct to <code>Either</code>, known as <code>\/</code>. If <code>\/</code> reads like a mouthful, you can call it Disjunction - which we’ll do in this post as well. A Disjunction can, like in <code>Either</code> have either a Left or a Right side - typically representative of a Success (right) or an Error (left). These are represented by symbols: <code>-\/</code> for Left, <code>\/-</code> for Right.</p>

<p><em>(I find, in general, that the easiest memory trick is to look at which side of the Disjunction the <code>-</code> appears on.)</em></p>

<p>With Disjunctions, there is an assumption that we prefer Success (the right, or <code>\/-</code>) - this is also known as Right Bias. With Right Bias, for comprehensions, <code>map</code>, and <code>flatMap</code> unpack for us where “success” (<code>\/-</code>) continues and “failure” (<code>-\/</code>) aborts.</p>

<p>When declaring a return type of a Disjunction, you should generally prefer to use the Infix notation for clarity sake. That is to say:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">def</span> <span class="n">query</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Error</span> <span class="kt">\/</span> <span class="kt">Success</span></code></pre></div></p>

<p>with the Infix notation for the return type, is preferable to this:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">def</span> <span class="n">query</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">\/</span><span class="o">[</span><span class="kt">Error</span>, <span class="kt">Success</span><span class="o">]</span></code></pre></div></p>

<p>the standard notation, which may not read as clearly.</p>

<p>As for declaring instances of Left or Right, there are a few options in <code>scalaz</code>. The first is postfix operators, <code>.left</code> and <code>.right</code>, which wrap an existing value in a Disjunction instance:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">import</span> <span class="nn">scalaz._</span>
<span class="lineno">2</span> <span class="k">import</span> <span class="nn">Scalaz._&lt;/p</span><span class="o">&gt;</span>
<span class="lineno">3</span> 
<span class="lineno">4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">Success</span><span class="o">!</span><span class="err">”</span><span class="o">.</span><span class="n">right</span>
<span class="lineno">5</span> <span class="n">res7</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">Nothing</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">\/-(</span><span class="nc">Success</span><span class="o">!)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">6</span> 
<span class="lineno">7</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="err">“</span><span class="nc">Failure</span><span class="o">!</span><span class="err">”</span><span class="o">.</span><span class="n">left</span>
<span class="lineno">8</span> <span class="n">res8</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="o">-\/(</span><span class="nc">Failure</span><span class="o">!)</span></code></pre></div></p>

<p>Alternately, we can use the Disjunction singleton instance instead:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">import</span> <span class="nn">scalaz._</span>
<span class="lineno">2</span> <span class="k">import</span> <span class="nn">Scalaz._&lt;/p</span><span class="o">&gt;</span>
<span class="lineno">3</span> 
<span class="lineno">4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="err">“</span><span class="nc">Failure</span><span class="o">!</span><span class="err">”</span><span class="o">)</span>
<span class="lineno">5</span> <span class="n">res10</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="o">-\/(</span><span class="nc">Failure</span><span class="o">!)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">6</span> 
<span class="lineno">7</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">\/.</span><span class="n">right</span><span class="o">(</span><span class="err">“</span><span class="nc">Success</span><span class="o">!</span><span class="err">”</span><span class="o">)</span>
<span class="lineno">8</span> <span class="n">res12</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">Nothing</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">\/-(</span><span class="nc">Success</span><span class="o">!)</span></code></pre></div></p>

<p>which, by virtue of being more explicit, may be clearer to the reader.</p>

<p>Finally, we can construct instances of Left and Right directly:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">import</span> <span class="nn">scalaz._</span>
<span class="lineno">2</span> <span class="k">import</span> <span class="nn">Scalaz._&lt;/p</span><span class="o">&gt;</span>
<span class="lineno">3</span> 
<span class="lineno">4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">-\/(</span><span class="err">“</span><span class="nc">Failure</span><span class="o">!</span><span class="err">”</span><span class="o">)</span>
<span class="lineno">5</span> <span class="n">res9</span><span class="k">:</span> <span class="kt">scalaz.-\/</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">-\/(</span><span class="nc">Failure</span><span class="o">!)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">6</span> 
<span class="lineno">7</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">scala</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">\/-(</span><span class="err">“</span><span class="nc">Success</span><span class="o">!</span><span class="err">”</span><span class="o">)</span>
<span class="lineno">8</span> <span class="n">res11</span><span class="k">:</span> <span class="kt">scalaz.\/-</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">\/-(</span><span class="nc">Success</span><span class="o">!)</span></code></pre></div></p>

<p>Remember I talked about how we could comprehend over Disjunctions, and success continued while failure aborted?</p>

<p><img src="/images/shining-grinning.gif" alt="Here's Johnny?" /></p>

<p>Let’s look at what that looks like with some sample data:</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno"> 1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">import</span> <span class="nn">scalaz._</span>
<span class="lineno"> 4</span> <span class="k">import</span> <span class="nn">Scalaz._&lt;/p</span><span class="o">&gt;</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">success1</span> <span class="k">=</span> <span class="o">\/.</span><span class="n">right</span><span class="o">(</span><span class="err">“</span><span class="nc">This</span> <span class="n">succeeded</span><span class="err">”</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">success2</span> <span class="k">=</span> <span class="o">\/.</span><span class="n">right</span><span class="o">(</span><span class="err">“</span><span class="nc">This</span> <span class="n">succeeded</span> <span class="n">also</span><span class="o">!</span><span class="err">”</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">fail1</span> <span class="k">=</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="err">“</span><span class="nc">This</span> <span class="n">failed</span> <span class="n">miserably</span><span class="err">…”</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">fail2</span> <span class="k">=</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="err">“</span><span class="nc">Oops</span> <span class="k">:</span><span class="o">(</span><span class="err">“</span><span class="o">)</span><span class="kt">&lt;/p&gt;</span>
<span class="lineno">13</span> 
<span class="lineno">14</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>We now have a couple of Disjunction instances we can use. If we comprehend over only Right, we get back an instance of Right.</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">for</span> <span class="o">{</span>
<span class="lineno">2</span>   <span class="n">one</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">success1</span>
<span class="lineno">3</span>   <span class="n">two</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">success2</span> 
<span class="lineno">4</span> <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">two</span><span class="o">)</span>
<span class="lineno">5</span> <span class="cm">/* res0: scalaz.\/[Nothing,(String, String)] = </span>
<span class="lineno">6</span> <span class="cm">      \/-((This succeeded,This succeeded also!)) */</span></code></pre></div></p>

<p>Since both instances we used were Right, we get back an instance of Right ( <code>\/-</code> ).</p>

<p>What if we include a Left in there?</p>

<p><div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="lineno">1</span> <span class="k">for</span> <span class="o">{</span>
<span class="lineno">2</span>   <span class="n">one</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">success1</span>
<span class="lineno">3</span>   <span class="n">two</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">fail1</span><span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
<span class="lineno">4</span>   <span class="n">three</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;-</span> <span class="n">success2</span>
<span class="lineno">5</span> <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">one</span><span class="o">,</span> <span class="n">three</span><span class="o">)</span>
<span class="lineno">6</span> <span class="cm">/* res1: scalaz.\/[String,(String, String)] = </span>
<span class="lineno">7</span> <span class="cm">      -\/(This failed miserably…) */</span></code></pre></div></p>

<p>The behavior here is much like with an <code>Option</code> instance of <code>None</code> (Which we’ll talk about in the next post). When Scala encounters a “failure” - in this case a Left ( <code>-\/</code> ) - it aborts the iteration and returns an instance of the failure. This case means the <code>yield</code> never gets run. This can be valuable as an easy way to work with multiple Disjunctions all of which needed to be Right.</p>

<p>Now you’ve had a (hopefully) gentle introduction to the world of <code>\/</code>. In <a href="http://bytes.codes/2015/04/13/a-skeptics-guide-to-scalaz-gateway-drugs-part-2-options-with-disjunction/">the next part</a>, we’ll talk about using Scala’s <code>Option</code> in conjunction with Disjunctions to better handle failure conditions with existing code.</p>
]]></content>
  </entry>
  
</feed>
